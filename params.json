{
  "name": "Ansible Container Demo",
  "tagline": "From development through cloud deployment, using containers to manage applications is easy with Ansible Container",
  "body": "The demo will take you through the complete lifecycle of a simple social media web app called *Not Google Plus*. The application itself comes from a [tutorial](https://thinkster.io/django-angularjs-tutorial), but not to worry, we won't be working through the tutorial. Instead, we'll focus on the mechanics of building, testing and deploying completed application.  \r\n\r\n## Requirements\r\n\r\nBefore continuing, you'll need a couple of things:\r\n\r\n - A Linux or OSX environment  \r\n - Ansible Container installed from source. See our [Running from source guide](http://docs.ansible.com/ansible-container/installation.html#running-from-source) for assistance.  \r\n - Docker Engine or Docker for Mac. See [Docker Installation](https://docs.docker.com/engine/installation/) for assistance.\r\n - [Ansible 2.1+](http://docs.ansible.com/ansible/intro_installation.html), if you plan to run the deployment\r\n\r\n## Getting Started\r\n\r\nAnsible roles can be used to initialize a new project or add services to existing projects. Roles are found on the [Ansible Galaxy](https://galaxy.ansible.com) web site, and there are two role types we can use with Ansible Container. The *container app* role contains a fully functioning app, and can be used to initialize an empty project. A *container enabled* role will add a service to an existing project, and it contains a Docker Compose service definition, a playbook, and any files needed to supporting building the service's container image.\r\n\r\nWe'll start by creating an empty project directory, and initializing it with the [ansible.django-gulp-nginx](https://galaxy.ansible.com/ansible/django-gulp-nginx) role. It's a *container app* role, providing us with a fully functioning Django framework. And because we're able to start with this role, the containerization and Django setup work is already done. All that's left is to add the source code for our new social media site, and we'll have a completed app. \r\n\r\nCreate the project folder, and initialize it by running the following commands from a terminal session:\r\n\r\n```\r\n# Create an empty directory called 'demo'\r\n$ mkdir demo\r\n\r\n# Set the working directory to demo\r\n$ cd demo\r\n\r\n# Initialize the project\r\n$ ansible-container init ansible.django-gulp-nginx\r\n``` \r\n\r\nYou now have a copy of the project in a directory called *demo*. Inside *demo/ansible* you'll find a `container.yml` file describing in [Compose](http://docs.ansible.com/ansible-container/container_yml/reference.html) the services that make up the application, and an Ansible playbook called `main.yml` containing a set of plays for building the application images. \r\n\r\n### Build the images\r\n\r\nTo run the application, you'll first need to build the images, and you can start the build by running the following command:\r\n\r\n```\r\n# Start the image build process\r\n$ ansible-container build\r\n```\r\n\r\n![Building the images](https://raw.githubusercontent.com/ansible/ansible-container-demo/gh-pages/images/build_01.png)\r\n\r\nThe build process launches a container for each service along with a build container. For each service container, the base image is the image specified in `container.yml`. The build container runs the `main.yml` playbook, and executes tasks on each of the containers. You'll see output from the playbook run in your terminal window as it progresses through the tasks. When the playbook completes, each image will\r\nbe `committed`, creating a new set of base images.\r\n\r\nWhen execution stops, use the `docker images` command to view the new images:\r\n\r\n```\r\n# View the images\r\n$ docker images\r\n\r\nREPOSITORY                          TAG                 IMAGE ID            CREATED             SIZE\r\ndemo-django                         20161205170642      dbe68f4e3c74        About an hour ago   1.28 GB\r\ndemo-django                         latest              dbe68f4e3c74        About an hour ago   1.28 GB\r\ndemo-nginx                          20161205170642      5becc50f69a9        About an hour ago   270 MB\r\ndemo-nginx                          latest              5becc50f69a9        About an hour ago   270 MB\r\ndemo-gulp                           20161205170642      0644893c80d7        About an hour ago   508 MB\r\ndemo-gulp                           latest              0644893c80d7        About an hour ago   508 MB\r\n```\r\n\r\n### Run the application\r\n\r\nNow that you have the application images built in your environent, you can launch the application and log into *Not Google Plus*. Run the following command to start the application:\r\n\r\n```\r\n# Launch the demo\r\n$ ansible-container run\r\n```\r\nYou should now see the output from each container streaming in your terminal window. The containers are running in the foreground, and they are running in *development mode*, which means that for each service the *dev_overrides* directive is being included in the configuration. For example, take a look at the *gulp* service definition found in `container.yml`:\r\n\r\n```\r\n  gulp:\r\n    image: centos:7\r\n    user: '{{ NODE_USER }}'\r\n    working_dir: '{{ NODE_HOME }}'\r\n    command: ['/bin/false']\r\n    environment:\r\n      NODE_HOME: '{{ NODE_HOME }}'\r\n    volumes:\r\n      - \"${PWD}:{{ NODE_HOME }}\"\r\n    dev_overrides:\r\n      command: [/usr/bin/dumb-init, /usr/bin/gulp]\r\n      ports:\r\n      - 8080:{{ GULP_DEV_PORT }}\r\n      - 3001:3001\r\n      links:\r\n      - django\r\n    options:\r\n      kube:\r\n        state: absent\r\n      openshift:\r\n        state: absent\r\n```\r\n\r\nIn development *dev_overrides* takes precedence, so the command ``/usr/bin/dumb-init /usr/bin/gulp* will be executed, ports 8080 and 3001 will be exposed, and the container will be linked to the *django* service container.\r\n\r\nIf you were to tun the *gulp* service in production, *dev_overrides* would be ignored completely. In production the ``/bin/false`` command will be executed, causing the container to immediately stop. No ports would be exposed, and the container would not be linked to the django container.\r\n\r\nSince the frontend tools gulp and browsersync are only needed during development and not during production, we use *dev_overrides* to manage when the container executes.\r\n\r\nThe same is true for the nginx service. Take a look at the service definition in `container.yml`, and you'll notice it's configured opposite of the gulp service:\r\n\r\n```\r\n  nginx:\r\n    image: centos:7\r\n    ports:\r\n    - {{ DJANGO_PORT }}:8000\r\n    user: nginx\r\n    links:\r\n    - django\r\n    command: ['/usr/bin/dumb-init', 'nginx', '-c', '/etc/nginx/nginx.conf']\r\n    dev_overrides:\r\n      ports: []\r\n      command: /bin/false\r\n    options:\r\n      kube:\r\n        runAsUser: 1000\r\n```\r\n\r\nIn development the nginx service runs the ``/bin/false`` command, and immediately exits. But in production it starts the \r\n``nginx`` process, and takes the place of the gulp service as the application's web server.\r\n\r\n### Tour the site \r\n\r\nNow that you have the application running, lets check it out! Watch the video below, and follow along on your local site to register, log in, and create posts. Your site will be reachable at [http://localhost:8080](http://localhost:8080), and you can browse the API directly at [http://localhost:8080/api/v1/](http://localhost:8080/api/v1/).\r\n\r\nClick the image below to watch the video:\r\n\r\n[![Site Tour](https://raw.githubusercontent.com/ansible/ansible-container-demo/gh-pages/images/demo.png)](https://youtu.be/XVOIVhcYd8M)\r\n\r\n### Stopping the containers\r\n\r\nOnce you're finished, you can press `ctrl-c` to kill the containers. This will signal Docker to kill the processes running inside the containers, and shut the containers down. This works when the containers are running in the foreground, streaming output to your terminal window.\r\n\r\nYou can also run `ansible-container stop`. For containers running in the foreground, open a second terminal window, set the working directory to your *demo* project, and run the command. It will terminate all containers associated with the project, regardless wether they're running in the foreground or in the backgound.\r\n\r\n## Testing the application\r\n\r\nIf you make code changes, and you want to test, you'll begin by building a fresh set of images that contain your code changes. During the build process the latest code gets added to the nginx image. So if you actually modified some code, go ahead and run the `build` command as follows, otherwise you can skip this step:\r\n\r\n```\r\n# Start the build process\r\n$ ansible-container build\r\n```  \r\n\r\nOnce the build process completes, you'll have a new set of images, which you can view using `docker images`\r\n\r\n```\r\n# View the images once again\r\n$ docker images\r\n\r\nREPOSITORY                          TAG                 IMAGE ID            CREATED             SIZE\r\ndemo-django                         20161205192107      103a28329385        4 minutes ago       2.31 GB\r\ndemo-django                         latest              103a28329385        4 minutes ago       2.31 GB\r\ndemo-gulp                           20161205192107      b264122208b5        5 minutes ago       534 MB\r\ndemo-gulp                           latest              b264122208b5        5 minutes ago       534 MB\r\ndemo-nginx                          20161205192107      7206eff9bf9b        5 minutes ago       295 MB\r\ndemo-nginx                          latest              7206eff9bf9b        5 minutes ago       295 MB\r\ndemo-django                         20161205170642      dbe68f4e3c74        2 hours ago         1.28 GB\r\ndemo-nginx                          20161205170642      5becc50f69a9        2 hours ago         270 MB\r\ndemo-gulp                           20161205170642      0644893c80d7        2 hours ago         508 MB\r\n```\r\n\r\nYou now have a newer set of images with your code changes baked into the nginx image. Now when you start the application in production mode or deploy it, your changes will be available.\r\n\r\n### Start in production mode \r\n\r\nFor testing you want to launch the application in *production mode*, so that it runs exactly the same as it does when deployed to the cloud. As we pointed out earlier, when run in production the *dev_overrides* settings are ignored, which means we'll see the gulp container stop and the nginx container start and run as our web server. To start the application in production mode, run the following command:\r\n\r\n```\r\n# Start the appliction in production mode\r\n$ ansible-container run --production\r\n```\r\n\r\nThe following video shows the application starting with the ``--production`` option. Click the image below to watch the video:\r\n\r\n[![Testing](https://raw.githubusercontent.com/ansible/ansible-container-demo/gh-pages/images/production.png)](https://youtu.be/ATpYJhG1RV0)\r\n\r\n## Deploy the application\r\n\r\nOnce the application passes testing, it's time to deploy it to production. To demonstrate, we'll create a local instance of OpenShift, push images to its registry, generate a deployment playbook, run it, and check the results.\r\n\r\n### Create a local OpenShift instance\r\n\r\nTo create an OpenShift instance you'll install the ``oc`` command line tool, and then run `oc cluster up`. The cluster runs in containers, making the install process almost trivial.\r\n\r\nYou'll find instructions in our [Install and Configure OpenShift guide](http://docs.ansible.com/ansible-container/configure_openshift.html) to help you create an instance. One available installation method is the Ansible role [chouseknecht.cluster-up-role](https://galaxy.ansible.com/chouseknecht/cluster-up-role), which is demonstrated in the following video:\r\n\r\n[![Creating an OpenShift instance](https://raw.githubusercontent.com/ansible/ansible-container-demo/gh-pages/images)](https://youtu.be/iY4bkHDaxCc)\r\n\r\nTo use the role, you'll need Ansible installed. Also, note in the video that the playbook is copied from the installed role's file structure. You'll find the playbook, *cluster-up.yml*, in the *files* subfolder.\r\n\r\nAs noted in the role's [README](https://github.com/chouseknecht/cluster-up-role/blob/master/README.md), if you have not already added the *insecure-registry* option to Docker, the role will error, and provide the subnet or IP range that needs to be added. You'll also need to add the value of the *openshift_hostname* option, which by default is *local.openshift*. For more about adding the --insecure-registry option see [Docker's documentation](https://docs.docker.com/registry/insecure/). \r\n\r\n### Create an OpenShift project\r\n\r\nNow that you have an OpenShift instance, run the following to make sure you're logged into the cluster as *developer*, and create a *demo* project:\r\n\r\n```\r\n# Verify that we're logged in as the *developer* user\r\n$ oc whoami\r\ndeveloper\r\n\r\n# Create a demo project\r\n$ oc new-project demo\r\n\r\nNow using project \"demo\" on server \"https://...:8443\".\r\n\r\nYou can add applications to this project with the 'new-app' command. For example, try:\r\n\r\n    oc new-app centos/ruby-22-centos7~https://github.com/openshift/ruby-ex.git\r\n\r\nto build a new example application in Ruby.\r\n```\r\n\r\n### Push the images\r\n\r\nBefore starting the application on the cluster, the images will need to be accessible, so you'll push them to the *demo* repository on the local registry.\r\n\r\nIf you ran the role to create the OpenShift instance or worked through our guide, then a new hostname, *local.openshift*, was created for accessing the registry, and the *developer* account now has full admin access. So you'll employ both of these as you execute the following commands to push the images:   \r\n\r\n```\r\n# Set the working directory to the demo project\r\n$ cd demo\r\n\r\n# Push the demo images to the local registry \r\n$ ansible-container push --push-to https://local.openshift/demo --username developer --password $(oc whoami -t)\r\n```\r\n\r\nThe following video shows the project's images being pushed to the local registry:\r\n\r\n[![Push images](https://raw.githubusercontent.com/ansible/ansible-container-demo/gh-pages/images/push.png)](https://youtu.be/KklXsFKd8gQ)\r\n\r\n### Generate the deployment artifacts \r\n\r\nNow you'll generate a playbook and role that are capable of deploying the application. From the *demo* directory, execute the `shipit` command as pictured below, passing the `--pull-from` option with the URL to the local registry:\r\n\r\n```\r\n# Generate the deployment playbook and role\r\n$ ansible-container shipit openshift --pull-from https://local.openshift/demo\r\n```\r\nRunning the above creates, a playbook, *shipit-openshift.yml*, in the *ansible* directory, and a role, *demo-openshift*, in the *ansible/roles* directory as demonstrated in the following video:\r\n\r\n[![Run shipit](https://raw.githubusercontent.com/ansible/ansible-container-demo/gh-pages/images/shipit.png)](https://youtu.be/4a8WKO5Kjlo)\r\n\r\n### Deploy!\r\n\r\nYou now have the deployment playbook and role. But before you run the playbook, you'll need to create an inventory file. If you're not familiar with Ansible, not to worry. A playbook runs a set of plays on a list of hosts, and the inventory file holds the list of hosts. In this case we want to execute the plays on our local workstation, which we can refer to as *localhost*, and so we'll create an inventory file containing a single host named *localhost*. Run the following to create the inventory file:\r\n\r\n```\r\n# Set the working directory to demo/ansible\r\n$ cd ansible\r\n\r\n# Create an inventory file\r\n$ echo \"localhost\">inventory\r\n```\r\nNow from inside the *demo/ansible* directory, run the following to launch the *Not Google Plus* site on your OpenShift instance:\r\n\r\n```\r\n# Run the playbook\r\n$ ansible-playbook -i inventory shipit-openshift.yml\r\n```\r\nOnce the playbook completes, the application will be running on the cluster, and you can log into the console to take a look. To access the application, you'll need the hostname assigned to the route, and you can discover that by clicking on *Applications*, and choosing *Routes*. From there click on the hostname link, and the application will be opened in a new browser tab.\r\n\r\nWatch the following video to see the full deployment:  \r\n\r\n[![Deploy the app](https://raw.githubusercontent.com/ansible/ansible-container-demo/gh-pages/images/deploy.png)](https://youtu.be/9i6iGMLyr44)\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}